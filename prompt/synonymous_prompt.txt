CRITICAL OUTPUT RULES
- Do not include Backticks ```
-Your response MUST start with: `import pandas as pd`
Output must be only executable Python code (no explanations, no text before/after code)

---
TASK
Detect and fix synonymous activity labels: different textual variations that represent the same logical activity.

Goal: Normalize synonyms by clustering activities using TF-IDF–based similarity and replace all synonym variants with the **canonical (most frequent)** form.
Example (conceptual):
* Before:
  * "Submit Form" (canonical – most frequent)
  * "submit_form" (synonym)
  * "submitting the form" (synonym)
  * "Form Submission" (synonym)
* After (all replaced with):
  * "Submit Form" (canonical)

---

INPUT CONFIGURATION
* `input_file` = path to CSV file
* `input_directory` = directory to write outputs
* `dataset_name` = dataset identifier (used in filenames)
* `output_suffix` = suffix for final, fixed CSV (e.g., `_fixed`)
* `detection_output_suffix` = suffix for optional intermediate detection CSV

Available columns:
* case_column = 'Case'
* activity_column = 'Activity'
* timestamp_column = 'Timestamp'
* label_column = 'label'   
The following columns are optional:
variant = 'Variant' (process variant ID)
resource = 'Resource' (actor / performer)
If they exist, they must be preserved and passed through to the output.
If they do not exist, the script must not fail.
---

PARAMETERS

* `similarity_threshold` (default: 0.40) — cosine similarity threshold for synonym grouping
* `min_synonym_group_size` (default: 2) — minimum size to consider a cluster valid
* `use_case_scope` (default: False) — if True, cluster per case; if False, cluster globally
* `ngram_range` (default: (1, 3)) — character n-gram range for TF-IDF
* `save_detection_file` (default: False) — whether to save intermediate detection view
* `label_column` (default: `label`) — label column name

---

REQUIRED BEHAVIOR (algorithm steps)

#1. Load and Validate

* Read CSV into a pandas DataFrame.
* Normalize column naming:
  * If `CaseID` exists and `Case` is missing, rename `CaseID` → `Case`.
* Ensure `Activity` column exists; raise a clear error if missing.
* Store original values: create `original_activity` from `Activity`.
* Ensure `Activity` is string-typed; fill missing with empty string.
* If `Timestamp` exists, parse to datetime (coerce errors).
* If both `Case` and `Timestamp` exist, sort by `Case`, then `Timestamp`.
* Print: dataset shape, first few rows, and number of unique `Activity` values.
* Why: Establishes a clean, consistent baseline for detection.

---

#2. Normalize Activity Labels

* Define `normalize_activity(activity)`:
  * Convert to lowercase.
  * Remove all non-alphanumeric characters **except spaces**.
  * Collapse multiple whitespace to single space; trim.
  * Return normalized text (empty string if NaN).
* Apply to build `Activity_clean` from `original_activity`.
* Replace empty cleans with a sentinel like `empty_activity`.
* Why: Reduces superficial differences (case, punctuation) before similarity.

---

#3. TF-IDF Embedding and Similarity

* Extract `unique_activities` from `Activity_clean` (unique values).
* If count < 2: set `is_synonymous_event = 0` for all rows, print warning, and skip clustering.
* Build TF-IDF vectorizer:
  * Analyzer: `char_wb` (character n-grams with word boundaries)
  * `ngram_range` per parameter
  * `lowercase=True`, `min_df=1`
* Fit/transform `unique_activities` → `tfidf_matrix`.
* Compute cosine similarity matrix between all unique activities.
* Print: TF-IDF matrix shape and unique activity count.
* Why: Character n-grams capture small surface variations robustly.

---

#4. Cluster Using Union-Find

* Initialize union-find over indices of `unique_activities`.
* For each pair `(i, j)` with `i < j`:
  * If `similarity_matrix[i, j] ≥ similarity_threshold`, union the sets.
* Build clusters by root parent; map indices to cluster lists.
* Keep only clusters with size `≥ min_synonym_group_size`.
* Create `activity_to_cluster` mapping:
  * Each `Activity_clean` → cluster id (−1 for unclustered).
* Print: number of synonym clusters discovered.
* Why: Union-find merges transitive similarities efficiently.

---

#5. Select Canonical Form (Majority/Mode)

* For each valid cluster:

  * Gather member `Activity_clean` strings.
  * Count each member’s total occurrences in the DataFrame.
  * **Canonical** = member with the highest frequency in the original data.
* Build `canonical_mapping`:

  * Each member `Activity_clean` in a cluster → its cluster canonical.
* Assign to DataFrame:

  * Create `SynonymGroup` (cluster id or −1).
  * Create `canonical_activity`: if clustered, set to cluster canonical; else keep `Activity_clean`.
  * Create `is_synonymous_event`:

    * 1 if in a cluster **and** not equal to its canonical.
    * 0 otherwise (canonical or unclustered).
* Why: The most common form is assumed to be the intended canonical label.

---

#6. Calculate Detection Metrics (BEFORE FIXING)

* If `label_column` exists:

  * Ground truth `y_true = 1` if label non-null and non-empty; else 0.
  * Predictions `y_pred = is_synonymous_event`.
  * Compute precision, recall, F1-score (handle zero divisions with 0).
  *Print:

    * `=== Detection Performance Metrics ===`
    * Precision, Recall, F1-Score (4 decimals)
* If no labels: Print all metrics as 0.0000 and note “No ground-truth labels available for evaluation”.
* Why: Quantifies how well synonym detection aligns with labels.

---

#7. Integrity Check

*Print:

  * Total synonym clusters found
  * Total events flagged as synonyms
  * Total canonical/clean events
* Confirm only clustered non-canonical items are marked for change.
* Why: Ensures non-synonymous data remains untouched.

---

#8. Fix Activities

* Replace `Activity` with `canonical_activity` for all rows (clustered rows map to canonical; unclustered remain unchanged).
* Why: Standardizes labels across synonyms to a single canonical form.

---

#10. Create Final Fixed Dataset

* Drop helper columns from a copy to produce the final output (e.g., `original_activity`, `Activity_clean`, `canonical_activity`, `SynonymGroup`, `is_synonymous_event`).
* Preserve all original non-helper columns (e.g., `Case`, `Timestamp`, `label`).
* Why: Outputs a clean, minimal dataset for downstream use.

---

#11. Save Output and Summary

* Save fixed dataset to:

  * `input_directory` + `/` + `dataset_name` + `output_suffix` + `.csv` (no index)
* Print summary:

  * Total rows
  * Synonym clusters found
  * Synonymous events replaced (count)
  * Replacement rate (% of rows)
  * Unique activities **before** → **after**
  * Activity reduction (count and %)
  * Output file path
* Print up to 10 sample transformations:

  * Format: `'original_activity' → 'canonical_activity'` (only where changed)
* Why: Confirms consolidation effect and provides quick validation.

---

CRITICAL REMINDERS

Normalization 

* Lowercasing and punctuation removal (excluding spaces) are required before TF-IDF.
* Collapse whitespace to ensure consistency.
* Keep a sentinel for empty results to avoid losing rows.

Similarity & Clustering 

* Use TF-IDF with `char_wb` analyzer and specified `ngram_range`.
* Cosine similarity drives union operations; ensure threshold is configurable.
* Union-find must include path compression for efficiency.

Canonical Selection 

* Choose canonical by maximum frequency in the full dataset.
* Only members within the same cluster map to the same canonical.

Metrics 
* `y_true`: label non-null/non-empty → 1; else 0.
* `y_pred`: `is_synonymous_event` (0/1).
* Always print metrics; if labels are absent, print zeros with an explanatory note.

Output Integrity 

* Preserve non-helper columns exactly.
* Do not alter unclustered activities.
* Ensure final `Activity` has no empty values after fixing.

---

SYNONYMOUS ILLUSTRATION

* “Submit Form”, “submit_form”, “submitting the form”, “Form Submission”
  * Normalize → “submit form”, “submit form”, “submitting the form”, “form submission”
  * High pairwise cosine similarity with character n-grams
  * Cluster together; canonical selected as the most frequent variant in data (e.g., “submit form”)
  * All mapped to canonical in final output

---

KEY REQUIREMENTS

1. Preserve originals in `original_activity`.
2. Normalize with lowercase, punctuation removal (except spaces), and whitespace collapsing.
3. Build TF-IDF (`char_wb`, `ngram_range`) and compute cosine similarity.
4. Cluster via union-find with threshold and minimum size.
5. Select canonical by frequency; map cluster members to canonical.
6. Compute and print detection metrics before fixing (labels optional).
7. Save optional detection file and the final fixed dataset.
8. Print a clear summary and sample transformations.
